## 앱이 실행되는과정
    1. main함수가 실행됩니다.
    2. main 함수가 UIApplicationMain 함수를 호출합니다.
    3. UIApplicationMain이 UIApplication 객체를 생성합니다.
    4. UIApplication 객체는 Info.plist에서 필요한 데이터를 로드합니다.
    5. UIApplication은 AppDelegate 인스턴스를 생성하고 UIApplication을 위임합니다.
    6. UIApplication은 RunLoop를 생성하고 초기설정을 진행합니다.
    7. 준비가 완료되면 AppDelegate의 didFinishLaunchingWithOptions를 호출합니다.
    8. 세션에 대한 설정이 완료되면 SceneDelegate의 willConnectToSession이 호출합니다.

## RunLoop에 대해서 설명해보세요
    
    **런루프는 스레드당 하나씩 생성**되어서 스레드에 작업이 생기면 처리하고, 아닐 때는 대기시키는 역할을 합니다.
    
    런루프는 메인 스레드를 제외한 스레드에서 자동으로 실행되지 않고 개발자가 직접 실행시켜 주어야합니다.
    
    런루프를 실행하면 실행되는 동안 도착한 이벤트를 실행합니다.
    
    런루프는 한번만 실행되고 실행이 끝나면 대기상태로 돌아갑니다.
    

## Bounds와 Frame의 차이점을 설명하시오
    
    Frame은 자신의 **상위뷰의 좌표계를 기준으로 위치를 나타내고**,
    Bounds는 **자신의 좌표계를 기준으로 위치를 나타냅니다**.
    
    **Frame의 사이즈**는 view를 감싸는 사각형 영역의 크기를 나타내고,
    **Bounds의 사이즈**는 view 자체의 크기를 나타냅니다.
    
    Frame의 위치를 변경하면 뷰가 이동하지만,
    Bounds는 뷰포트가 이동합니다.
    

## Bounds를 사용하는 예시
    
    스크롤 뷰에서 사용합니다. 스크롤 될 때마다 뷰의 Bounds를 업데이트 하게됩니다. 왼쪽으로 Swipe 하면 Bounds의 x좌표가 증가합니다.
    

## 실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것
    
    개발환경에서 시뮬레이터를 사용할 경우 세 손가락 이상의 터치 제스쳐는 사용할 수 없습니다.
    
    시뮬레이터에서는 카메라, 마이크, 전화, 센서를 사용할 수 없습니다.
    
    백그라운드 전환, 터치 등 기본적인 기능은 시뮬레이터에서도 사용할 수 있습니다.
    
    다크모드, 개발자용 네트워크 설정도 시뮬레이터에서 사용할 수 있습니다.
    

## OperationQueue 와 GCD Queue 의 차이점
    
    OperationQueue는 Objective C 기반의 API이고, GCD는 C 기반의 API입니다. 
    
    OperationQueue를 사용할 경우 내부의 태스크에 대한 제어를 할 수 있다고 알고 있습니다.
    
    → 작업 취소, 작업의 상태 변경 유무, 작업의 재사용, 작업의 우선순위, 의존성을 제공합니다.
    
    GCD는 오버헤드가 적고 관찰, 작업 취소 등을 지원하고 큐의 우선순위를 제공합니다.
    

## GCD API 동작 방식과 필요성
    
    우선 GCD API가 필요한 이유는 직접 스레드를 생성하지 않고 GCD 큐에 Task를 넣기만하면 자동으로 스레드를 생성, 실행, 관리하여 쉽게 동시성 코드를 작성할 수 있게 해주기 때문입니다.
    
    GCD는 Queue들로 이루어져 있고, 직렬, 병렬, 비동기, 동기 속성의 큐를 가질 수 있습니다.
    

## 앱의 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체를 무엇이라고 하는가?
    
    UserDefaults, CoreData, Realm 등이 있습니다.
    
    UserDefaults는 키-값 쌍으로 저장을 할 수 있고, 대용량의 데이터보다 단일 데이터를 보관하는데 사용합니다.
    
    CoreData는 객체 그래프를 관리하기 위한 프레임워크입니다. 테이블을 사용하지 않고 객체를 생성하여 데이터를 저장합니다. 따라서 개발자가 빠르고 쉽게 데이터를 사용할 수 있습니다.
    
    Realm은 모바일에 특화된 오픈소스 객체 데이터베이스 관리 시스템입니다. SQLite, Core Data보다 속도가 빠르고 성능면에서 더 우수합니다. 코드의 양이 적어 사용성이 좋고, 메인 스레드에서 데이터의 읽기, 쓰기 작업을 모두 할 수 있습니다.
    
    Realm을 사용한 이유는? 간단한 메모 어플이었기 때문에 로컬 DB를 사용하기로 결정했습니다.
    CoreData도 객체 형태로 데이터를 관리할 수 있다는 장점이 있었지만, XCode를 통해서 Entity를 생성하고, 코드로 데이터를 Read, write 하는 과정이 직관적이지 않고 사용이 조금 불편하다는 글을 보고 Realm을 먼저 사용해보기로 결정했습니다.
    

## 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?
    
    `UIViewController` 입니다.
    
    UIViewController는 UIKit 앱의 뷰 계층 구조를 관리하는 객체이고, 사용자와 상호작용에 응답합니다. 또한 전체 인터페이스의 레이아웃을 관리하고, 뷰의 콘텐츠를 업데이트할 수 있습니다.
    

## scene delegate에 대해 설명하시오.
    
    iOS 13 부터 멀티 윈도우를 지원하기 시작하여 한 프로세스가 여러개의 화면을 가질 수 있게 되었습니다. 따라서 각 화면의 생명주기를 관리할 필요가 생겼기 때문에 app delegate 가 담당했던 UI 생명주기와 관련된 메서드를 처리합니다.
    

## App thinning에 대해서 설명하시오.
    
    디바이스에 앱이 설치될 때, 기기 및 운영체제 버전에 맞게 최소한의 설치공간을 사용할 수 있도록하는 설치 최적화 기술을 의미합니다. 최소한의 디스크 사용과 빠른 다운로드가 가능합니다.
    
    - 슬라이싱
        - 앱을 구성하는 여러 버전의 실행가능한 코드와 리소스들 중 디바이스에 맞는 버전만 설치하게 합니다.
        - 개발자가 앱스토어 커넥트에 앱을 업로드하면, 앱스토어에서 다양한 버전의 조각들을 생성하고 사용자가 가장 알맞는 조각을 다운로드하게 합니다.
    - 비트코드
        - 앱스토어에 앱을 올릴 때 기계어로 구성된 바이너리 파일이 아니라 전 단계인 비트코드로 업로드 하는 것을 의미합니다. 비트코드로 된 파일 중 사용자 환경에 맞는 비트코드들만 다시 컴파일하여 바이너리 파일을 만들 수 있습니다.
    - 주문형 리소스
        - 사용자가 일부 리소스를 필요할 때만 다운로드 받는 방식입니다..

## 앱이 시작할 때 main.c 에 있는 UIApplicationMain 함수에 의해서 생성되는 객체는 무엇인가?
    
    UIApplication, App Delegate, SceneDelegate 객체가 생성됩니다.
    
    그리고 앱의 루트가 되는 window 객체를 생성하고 initial 뷰컨트롤러를 할당합니다.
    

## UIApplication 객체는 어떤 일을 하는지?
    
    UIApplication은 UIApplicationMain 에서 만들어지는 싱글톤 객체입니다. 
    
    UIApplication 은 런루프를 포함하는 메인 이벤트 루프를 만들고 이벤트 처리를 시작합니다
    
    그리고 AppDelegate에 Delegate를 위임합니다.
    
    delegate에게 중요한 런타임 이벤트를 알리고 응답할 기회를 제공합니다.
    
    사용자 이벤트를 처리하는 것
    

## UIApplicationDelegate는 어떤 종류의 메서드들을 포함하고 있는지?
    
    앱의 라이프 사이클이 변화될 때마다 상응하는 메서드가 있습니다.
    
    백그라운드에서 다운로드 작업이 진행되어야할 때의 메서드가 있습니다.
    
    앱의 Scene이 새로 생성되거나 지워질 때 호출되는 메서드가 있습니다.
    
    앱의 실행이 시작되면서 등록해야하는 서비스 작업들에 대한 메서드가 있습니다.
    

## @Main에 대해서 설명하시오.
    
    AppDelegate.swift 라는 파일이 AppDelegate 클래스를 정의하고 앱이 시작되는 진입점을 알려주고 runLoop를 포함하는 main event loop 를 만들고 이벤트 처리를 시작합니다.
    
    따라서 @Main 은 프로그램 실행 시작 시 진입점으로 타입을 지정하기 위한 스위프트의 언어 기능입니다.
    
    [[iOS & Swift 5.3+] @main : type기반의 프로그램 진입점](https://barosalki.tistory.com/entry/iOS-Swift-53-main-type%EA%B8%B0%EB%B0%98%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%A7%84%EC%9E%85%EC%A0%90)
    

## 앱이 foreground에 있을 때와 background에 있을 때 어떤 제약사항이 있나요?
    
    foreground에 있을 때 메모리 및 기타 시스템 리소스에 대해 background보다 높은 우선순위를 가지며 시스템은 이러한 리소스를 사용할 수 있도록 필요에 따라 background 앱을 종료합니다.
    
    background에 있을 때에는 가능한 적은 메모리 공간을 사용해야하며 자원할당에 있어 우선순위가 낮습니다.
    

## 상태 변화에 따라 다른 동작을 처리하기 위한 앱델리게이트 UIApplicationDelegate 메서드들을 설명하시오.
    
    ```
    //애플리케이션이 실행된 직후 사용자의 화면에 보여지기 직전에 호출
    func application(_ application: UIApplication, **didFinishLaunchingWithOptions** launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool
    
    //애플리케이션이 최초 실행될 때 호출되는 메소드
    func application(_ application: UIApplication, **willFinishLaunchingWithOptions** launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool
    
    //애플리케이션이 InActive 상태로 전환되기 직전에 호출  task 일시정지, 타이머 비활성화, 일시정지(게임)
    func **applicationWillResignActive**(_ application: UIApplication)
    
    //애플리케이션이 백그라운드 상태로 전환된 직후 호출
    func **applicationDidEnterBackground**(_ application: UIApplication)
    
    //애플리케이션이 Active 상태가 되기 직전, 화면에 보여지기 직전에 호출
    func **applicationWillEnterForeground**(_ application: UIApplication)
    
    //애플리케이션이 Active 상태로 전환된 직후 호출
    func **applicationDidBecomeActive**(_ application: UIApplication)
    
    //애플리케이션이 종료되기 직전에 호출
    func **applicationWillTerminate**(_ application: UIApplication)
    ```
    

## 앱이 In-Active 상태가 되는 시나리오를 설명하시오.
    
    시리가 켜지거나 전화알림, alert가 뜨는 상황 등 사용자로부터 이벤트를 받지 못하는 상황에서 In-active 상태가 됩니다.
    

## UIApplication 객체의 컨트롤러 역할은 어디에 구현해야 하는가?
    
    

## App의 Not running, Inactive, Active, Background, Suspended에 대해 설명하시오.
    
    `Not running` 은 실행되지 않은 상태이고 
    
    `Inactive` 는 실행상태지만 아무런 이벤트를 받을 수 없는 상태, 
    
    `Active` 는 이벤트가 발생한 상태입니다. 
    
    `Background` 는 백그라운드에서 코드를 실행중인 상태이고,
    
    백그라운드에서 코드를 실행하지 않으면 `Suspended` 상태가 됩니다.
    
    `background`: 사용자가 인지하지 못하는 영역에서 에너지와 리소스를 효율적으로 사용하기 위해 사용합니다.
    

## GCD의 Qos에 대해 설명해보세요
    - Qos 는 DispatchQueue에 등록하는 `작업의 우선순위`를 결정할 수 있게 합니다.
    - 우선순위가 높은 작업은 우선순위가 낮은 작업보다 먼저 실행되지만 앱의 리소스를 많이 사용합니다.

## Global DispatchQueue 의 Qos 에는 어떤 종류가 있는지, 각각 어떤 의미인지 설명하시오.
    - `userInterative`: 가장 우선순위가 높습니다. UI작업 등 사용자에게 즉각적인 반응을 해야하는 작업에 사용합니다.
    - `userInitiated`: 문서를 열람하거나 인터페이스에 제스쳐를 취하는 등 사용자와의 상호작용이 시작되었을 때 곧바로 결과를 반환해야 하는 작업에 사용합니다.
    - `default`: 기본값입니다. 일반적인 작업에 사용합니다.
    - `utility`: 데이터를 다운로드 하는 등 결과를 만들기 위해 시간이 걸리는 작업에 사용합니다. 프로그래스 바나 액티비티 인디케이터와 함께 사용합니다.
    

## iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?
    
    `UIKit`
    
    사용자의 인터페이스와 이벤트 처리가 주 목적인 프레임워크입니다.
    
    주로 처리하는 사용자 이벤트로는 `제스처`, `애니메이션`, `이미지`, `텍스트` 등이 있다.
    
    또한 `tableView`, `slider`, `button`, `textField`, `alert` 등 애플리케이션의 화면을 구성하는 요소도 포함한다.
    

## Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있는지 설명하시오.
    
    스위프트에서 사용하는 Int, String 과 같은 기본타입들과 Arrya, Dictionary 같은 컬렉션 타입이 있고 기본적인 기능을 제공하는 프레임워크입니다.
    

## Delegate란 무엇인가 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.
    
    Delegate 는 자신의 역할을 다른 누군가에게 위임하는 것입니다.
    
    일반적으로 프로토콜로 위임할 동작들의 인터페이스를 적용한 뒤에 이 프로토콜을 위임을 받을 곳에서 채택합니다. 그리고 위임을 해줄 타입을 weak var delegate 로 만들어두고 특정한 메서드를 호출할때 delegate에 구현되어 있는 메서드를 호출하면 이를 위임받아 프로토콜을 채택하는 타입이 해당 메서드 작업을 대신 처리하게 됩니다.
    
    weak var 로 선언하기 때문에 retain이 발생하지 않습니다.
    

## NotificationCenter 동작 방식과 활용 방안에 대해 설명하시오.
    
    NotificationCenter는 싱글톤 객체로 notification을 보낼 객체들을 addObserver로 등록합니다. Notification을 보낼 때는 post 함수를 호출하여 주어진 정보를 notificationcenter의 객체들에게 보내게됩니다.
    
    옵저버 패턴이지만 중간 역할을 하는 NotificationCenter가 있기 때문에 한번에 여러 객체에게 정보를 보내고자할 때 브로드캐스팅의 목적으로 사용할 수 있습니다.
    

## UIKit 클래스들을 다룰 때 꼭 처리해야하는 애플리케이션 쓰레드 이름은 무엇인가?
    
    UI와 관련된 모든 작업은 main 스레드에서 처리됩니다.
    

## App Bundle의 구조와 역할에 대해 설명하시오.
    
    앱 번들은 앱을 성공적으로 실행시키기 위해 실행가능한 파일, 코드, 리소스로 이루어져 있습니다. 앱 샌드박스 안에는 Documents, Library, Tmp 등이 있고, 이중에서 라이브러리 안에는 Application Support, Caches, Preferences 등의 디렉토리가 있습니다.
    
    샌드박스는 앱의 외부 데이터에 대한 접근을 제한하는 커널 수준에서 시행되는 접근 제어 기술이라고 할 수 있습니다.
    

## 모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인가?
    
    UIViewController 입니다.
    
    UIViewController의 역할은 뷰를 업데이트하고 사용자 이벤트와 상호작용합니다
    

## 자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.
    
    저는 UI클래스를 상속받아서 새로운 view class를 만들거나 extension으로 새로운 함수를 만들어 return 해서 사용하는 방식으로 커스텀 뷰를 만듭니다.
    

## View 객체에 대해 설명하시오.
    
    View는 사용자 인터페이스의 기본 구성 요소이며 화면에 컨텐츠 표시, 그리기 및 애니메이션, 오토레이아우스 제스처 등 화면에 대한 것들을 담당하는 객체입니다.
    

## UIView 에서 Layer 객체는 무엇이고 어떤 역할을 담당하는지 설명하시오.
    
    CALayer 타입의 객체입니다. CA는 Core Animation 프레임워크의 약자이며 애니메이션이나 복잡한 화면에 대한 처리를 담당합니다. CALayer는 별도의 스레드에서 GPU를 사용해 화면을 그리는 작업을 수행하는 객체입니다.
    

## UIWindow 객체의 역할은 무엇인가?
    
    UIWindow는 사용자 인터페이스에 배경(backdrop)을 제공하고, 중요한 이벤트 처리 행동(behaviors)을 제공하는 객체입니다.Windows는 자신의 시각적 모습(visual appearance)을 가지고 있지 않지만, 앱 View의 프레젠테이션에 중요합니다.
    
    UIWindow는 직접적으로 시각적인 내용을 나타내지는 않지만 앱의 view의 기본 컨테이너 제공하는 객체입니다.
    

## UINavigationController 의 역할이 무엇인지 설명하시오.
    
    stack 형태로 화면을 쌓아서 화면간 이동을 관리하는 역할을 합니다.
    

## TableView의 동작 방식과 화면에 Cell을 출력하기 위해 최소한 구현해야 하는 DataSource 메서드를 설명하시오.
    
    dequeueReusableCell 함수가 지정된 재사용 식별자에 대한 재사용 가능한 테이블 뷰 셀 객체를 반환하고 이를 테이블에 추가합니다.
    
    - dequeueReusableCell을 사용하는 이유는?
        
        사용하는 메모리를 줄이기 위해 사용합니다. 인덱스가 매우 많을 때 화면에 보여지는 셀만 메모리를 차지하고 나머지는 reuse poll에 들어가 필요할 때만 꺼내 씁니다.
        
    
    인덱스마다 반환할 셀을 결정하는 cellForRowAt과 섹션마다 표시할 셀의 갯수를 반환하는 numberOfRowsInSection이 있습니다.
    

## 하나의 View Controller 코드에서 여러 TableView Controller 역할을 해야 할 경우 어떻게 구분해서 구현해야 하는지 설명하시오.
    
    테이블뷰의 인스턴스를 함수의 tableView 인자와 같은지 비교하여 구분할 수 있습니다.
    

## setNeedsLayout와 setNeedsDisplay의 차이에 대해 설명하시오.
    
    setNeedsLayout은 뷰의 위치와 크기를 업데이트하는 `layoutSubviews`를 다음 업데이트 사이클에 호출하도록 예약하는 메서드입니다.  (뷰의 내용)
    
    setNeedsDisplay는 뷰의 내용을 그리는 `draw` 메서드를 다음 업데이트 사이클에 호출하도록 예약하는 메서드입니다.  (레이아웃을 다시 그려야 함)
    

## NSCache와 딕셔너리로 캐시를 구성했을때의 차이를 설명하시오.
    
    NSCache는 내부적으로 캐시정책을 가지고 있어서 저장하는 오브젝트의 개수나 cost를 정해두고 초과되면 정책에 따라 오브젝트를 삭제합니다. 딕셔너리는 내부적으로 따로 정책이 없고 NScache는 thread-safe 하기도 합니다.
    

## URLSession에 대해서 설명하시오.
    
    iOS에서 제공하는 HTTP를 이용해 네트워킹 통신을 할 수 있도록 도와주는 기본 프레임워크의 클래스입니다. URLSession은 thread-safe 하기 때문에 어떤 스레드에서든 자유롭게 Session과 Task를 생성할 수 있습니다.
    
    The URLSession API is thread-safe. 어떤 쓰레드 컨텍스트에서도 세션 및 태스크를 자유롭게 생성할 수 있다. 델리게이트가 제공한 completion handler를 호출하면 작업이 올바른 델리게이트 큐에 자동적으로 스케쥴된다.
    
    네트워크 통신을 제공하는 기본 프레임워크의 클래스 입니다.
    
    SessionTask를 만들고 통신에 대한 설정과 콜백을 정의해서 넘기면 네트워크 통신이 완료되었을 때 클로저가 실행됩니다.
    

## prepareForReuse에 대해서 설명하시오.
    
    prepareForReuse는 테이블 뷰나 컬렉션 뷰에서 셀을 재사용할 때 호출되는 메서드입니다. 화면에서 사라진 셀은 리유저블 큐에 저장되고 cellForItemAt 에서 dequeue되었을 때 다시 재사용됩니다. prepareForReuse는 cellForItemAt 이 호출되기 전에 호출되어서 셀의 설정들을 초기화할 수 있도록 도와줍니다.
    

## 다크모드를 지원하는 방법에 대해 설명하시오.
    
    asset에서 다크모드와 일반모드의 컬러셋을 설정해줄 수 있습니다.
    
    그리고 userInterfaceStyle 프로퍼티를 통해 현재 디바이스가 다크모드인지 라이트모드인지 확인하여 인터페이스를 세팅해줄 수 있습니다.
    

## ViewController의 생명주기를 설명하시오.
    
    `loadView` → `viewDidLoad` → `viewWillAppear` → `viewWillLayoutSubviews` → `viewDidLayoutSubviews` → `viewDidAppear` → `viewWillDisappear` → `viewDidDisappear`
    
    - viewWillLayoutSubviews : 뷰의 바운드가 설정되고 레이아웃이 변경되기 직전에 호출됩니다.
    - viewDidLayoutSubviews : 레이아웃이 설정되면 호출됩니다.

## TableView와 CollectionView의 차이점을 설명하시오.
    
    테이블뷰는 기본적으로 상하스크롤 목록만을 지원합니다.
    
    반면에 컬렉션 뷰는 플로우 레이아웃이나 compositional 레이아웃으로 목록의 레이아웃을 더 다양하게 구성할 수 있습니다.
    

# **Autolayout**

## 오토레이아웃을 코드로 작성하는 방법은 무엇인가? (3가지)
    - NSLayoutConstraint, Anchor, 비주얼 포맷 세가지 방법이 있습니다.
    - NSLayoutContraint는 item, attribute, multiplier, contraint를 지정해서 두 객체간의 레이아웃 관계를 정의하는 방법입니다.
    - NSLayoutAnchor는 NSLayoutConstraint를 더 간단한 API로 만든 것으로 Anchor와 constraint를 통해 객체간의 레이아웃 관계를 정의할 수 있습니다.
    - 비주얼 포맷은 아스키 문자열을 통해 레이아웃을 시각적으로 표현하여 레이아웃을 정의하는 방법입니다.

## hugging, resistance에 대해서 설명하시오.
    
    hugging은 최대 크기에 대한 제한이고, resistance는 최소 크기에 대한 제한입니다.
    
    따라서 허깅의 우선순위가 다른 뷰들보다 높은 뷰는 더 커지지 않으려고 하고  resistence의 우선순위가 다른 뷰들보다 높은 뷰는 더 작아지지 않으려고 합니다.
    
    - 예를 들어 길이가 정해진 스택 뷰 안에 두 UILabel이 있다고 했을 때, 왼쪽 뷰의 hugging priority가 더 높은 뷰는 스택뷰를 채우기 위해 길이를 늘리지 않고, 오른쪽 뷰가 길이를 늘려 스택뷰를 채우게 됩니다.
    - 반대로 resistence priority가 더 높은 뷰는 더 작아지지 않으려고 하기 때문에 스택뷰의 크기가 두 UILabel의 컨텐츠를 모두 표시하지 못하는 크기라면, resistence priority가 더 낮은 뷰의 크기가 줄어듭니다.

## ~~Intrinsic Size에 대해서 설명하시오.~~
    
    Intrinsic 사이즈는 UIButton, UILabel 등에서 사용되어서 뷰 내부의 컨텐츠에 따라 계산되는 뷰의 크기를 의미합니다. 커스텀 뷰에서는 이 프로퍼티를 오버라이딩해서 크기를 계산해주고 invalidIntrinsicContentSize를 호출해주어야 합니다.
    

## 스토리보드를 이용했을때의 장단점을 설명하시오.
    
    시각적인 피드백을 바로 가지고 수정할 수 있습니다.
    
    하지만 뷰의 재사용이 어렵고 화면이 많아지면 프로젝트를 로드하는 속도가 느려진다는 점, 여러사람이 협업 시 충돌이 쉽게 발생한다는 단점이 있습니다.
    

## Safearea에 대해서 설명하시오.
    
    디바이스의 노치 영역과 하단 홈 바 영역을 말합니다. 기본적으로 앱이 이 영역을 침범하지 못하도록 safearea를 기준으로 오토레이아웃을 설정합니다.
    

## Left Constraint 와 Leading Constraint 의 차이점을 설명하시오.
    
    문자에 대한 제약을 설정할 때 Left는 항상 문자의 시작을 왼쪽에 두지만 Leading은 언어에 따라서 우측에서 좌측으로 읽는 언어는 시작을 오른쪽에, 좌측에서 우측으로 읽는 언어는 시작을 왼쪽에 둡니다.
    

## `#selector` 의 역할이 무엇인가요?
    
    Objective-C 런타임으로 실행되는 메서드를 지정하기 위해서 사용합니다.
    

## UIControl에 대해서 설명해주세요
    
    UIControl은 UIView를 상속받는 객체로 사용자의 인터렉션에 대한 기능을 제공합니다. UIControl은 상태 정보를 제공하고 addTarget으로 UIControl 객체에서 어떤 이벤트가 발생했을 때 처리할 메서드를 지정할 수 있습니다.
    
    사용자 상호작용에 대한 응답으로 특정 작업을 전달하는 시각적 요소들의 기반이 되는 클래스입니다. Target-Action 의 매커니즘을 사용하여 액션들을 앱에 전달합니다.
    

## UIControl에서 이벤트가 발생하면 해당 이벤트를 처리하기까지의 과정을 설명해주세요.
    
    UIControl은 addTarget 메서드를 사용해서 이벤트 처리를 할 수 있습니다. 이때 타겟과 액션을 인자로 전달할 수 있습니다. 타겟은 일반적으로 이벤트를 처리할 뷰 컨트롤러를 지정합니다. 
    
    액션은 이벤트를 처리할 메서드에 대한 시그니처를 나타냅니다. 만약 이벤트가 발생하면 UIControl 객체는 이 메서드를 호출하고 UIApplication이 호출 메세지를 받아 이벤트를 전달합니다.
    

## UIResponder에 대해 설명해주세요
    
    UIResponder는 모든 UIView의 상위 객체이면서 이벤드를 받아 처리하거나 다른 UIResponder 객체에게 전달하는 역할을 합니다. 
    
    UIKit은 first responder에게 발생한 이벤트를 전달하고 UIResponder는 해당 이벤트를 자신이 처리할 수 있다면 처리하고, 처리할 수 없다면 next 프로퍼티에 할당된 다음 Responder에게 전달합니다.
    

## 기본적으로 클래스별로 이벤트가 전달되는 순서
    
    UIView, UIViewController, UIWindow, UIApplication, UIApplicationDelegate 순으로 이벤트가 전달됩니다.
    
    만약 어떤 뷰나 뷰 컨트롤러가 상위뷰에 속해져있는 뷰라면 해당 뷰나 뷰 컨트롤러에 이벤트를 전달합니다.
    

## 이벤트는 어떤 형태로 전달되는지?
    
    이벤트는 UIEvent 객체로 전달됩니다. 터치 이벤트는 UITouch 객체로 관리되고 UIEvent 객체를 통해 접근할 수 있습니다. 터치 이벤트 객체는 터치된 시간, 영역, 강도, 위치 등의 정보를 포함하고 있습니다.
    

## UI작업을 메인스레드에서 처리해야하는 이유
    
    UI는 런루프의 한 사이클 끝에서 변경됩니다. 만약 여러 스레드에서 UI작업을 처리하게 되면 각각 다른 런루프에서 작업을 처리하게되고, 뷰가 화면에 그려지는 시점이 제각각이 되거나 레이아웃이 의도와 다르게 그려질 수 있습니다.
    

# **Swift**

## struct와 class와 enum의 차이를 설명하시오.
    
    struct와 enum은 값 타입이고 class는 레퍼런스 타입입니다.
    
    struct와 enum은 스택 영역에 저장되고 class는 힙 영역에 저장됩니다.
    
    struct와 enum은 상속이 되지 않는 반면에 class는 상속이 가능합니다.
    

## Swift의 업캐스팅과 다운캐스팅의 차이에 대해서 설명해보세요
    
    서로 상속관계에 있는 클래스에서 자식 클래스를 부모 클래스로 타입캐스팅 하는 것을 업캐스팅이라고 하고 as를 사용해서 업캐스팅할 수 있습니다.
    

## == 연산자와 === 연산자의 차이점
    
    == 연산자는 값을 비교하는데 사용되고 === 연산자는 참조 값을 비교하는데 사용됩니다.
    

## 디스패치 큐의 시리얼 큐에 대해서 설명해보세요
    
    시리얼 큐는 작업을 한번에 하나씩 처리하는 큐 입니다.
    

## Enum에서 raw value와 associated value에 대해 설명해보세요
    
    raw value는 원시값으로 열거형의 모든 case들이 동일한 타입을 가지고 하나의 값만 가질 수 있습니다.
    
    associated value 연관값은 튜플을 통해 각 case들이 다른 타입을 가지게 할 수도 있고, 여러개의 값을 가지게 하는 것도 가능합니다.
    

## 열거형도 Hashable을 채택했을 때 자동으로 Hashable 하게 만들 수 있나요?
    
    열거형은 연관값이 없는 경우에 Hashable 프로토콜만 채택해도 Hashable하게 사용할 수 있지만 연관값이 있는 경우에는 Hash 메서드를 구현해주어야합니다.
    

## inout은 언제 사용할까요?
    
    함수 내에서 함수의 파라미터로 받은 값이 변경되었을 때 함수 외부에서도 동일하게 적용되어야 ㄹ할 때 사용합니다.
    

## class의 성능을 향상 시킬수 있는 방법들을 나열해보시오.
    
    final class 선언

## Swift의 참조타입
    
    클래스, 함수, 클로저
    

## Copy On Write는 어떤 방식으로 동작하는지 설명하시오.
    
    Copy On Write는 값을 복사해서 넣었을 때 같은 메모리 공간을 사용하지만, 어떤 한 값이 변경되었을 때 메모리 공간을 할당하는 방식으로 동작하여 메모리를 최적화시키는 기법입니다.
    

## Convinience init에 대해 설명하시오.
    
    클래스에서 지정생성자를 호출하는 생성자 입니다. 모든 저장속성의 값을 파라미터로 받지 않아도 생성자를 생성할 수 있기 때문에 개발자들이 필요한 값만을 받아서 생성자로 사용할 수 있습니다.
    

## AnyObject에 대해 설명하시오.
    
    클래스 타입을 나타냅니다.
    

## Optional 이란 무엇인지 설명하시오.
    
    메모리에서 값이 없을 때 접근하면 에러로 앱이 종료되는데 이를 방지하기 위해서 사용하는 값입니다. Optional 값을 바인딩하여 사용할 수 있습니다.
    
    Optional은 내부적으로 연관값을 가지는 열거형으로 구현되어 있습니다. 값이 존재할 때는 some에 저장된 값을 반환하고 값이 존재하지 않으면 nil을 반환합니다.
    

## Struct 가 무엇이고 어떻게 사용하는지 설명하시오.
    
    구조체는 값타입으로 스택영역에 저장됩니다. 상속관계가 필요없고 일반적으로 데이터 값을 저장할 때 사용합니다.
    

## Subscripts에 대해 설명하시오.
    
    인덱스를 통해 값을 접근할 수 있게 도와주는 특별한 메서드 입니다.
    
    subscript(index: Int) 메서드를 구현해서 사용할 수 있고 get set에 동작을 정의하여 사용할 수 있습니다.
    

## String은 왜 subscript로 접근이 안되는지 설명하시오.
    
    String은 정수형태로 subscript에 접근할 수 없는데 이는 Swift가 유니코드 체계로 이루어져 있어 글자마다 사용하는 메모리의 크기ㄲ가 다르기 때문입니다.
    

## instance 메서드와 class 메서드의 차이점을 설명하시오.
    
    인스턴스 메서드는 그 타입으로 접근할 수 있지만 클래스 메서드는 인스턴스를 생성해야 접근할 수 있습니다.
    

## class 메서드와 static 메서드의 차이점을 설명하시오.
    
    두 메서드 모두 타입 프로퍼티로 클래스, 구조체, 열거형에 모두 사용할 수 있습니다.
    
    타입 프로퍼티는 lazy하게 동작하여 실제로 불리기 전까지는 메모리에 로드되지 않습니다.
    
    타입 프로퍼티는 한번 불리면 메모리에 로드되고 그 이후로는 새로 생성되지 않습니다.
    
    타입 프로퍼티는 타입 이름을 통해서만 접근이 가능하고 항상 초기값을 가져야합니다.
    
    **class로 선언된 타입 프로퍼티는 오버라이딩이 가능하지만 static은 불가능합니다.**
    

## Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.
    
    Delegate 
    
    다른 객체에게 자신의 일을 위임하는 형태의 디자인패턴 Delegate는 어떤 객체가 해야하는 일을 부분적으로**확장**해서 대신 **처리**를 한다.
    
    tableview, collectionview를 생성하고 클릭할 때 Delegate 패턴을 사용합니다. Delegate 프로토콜을 채택하여 해당 일을 넘겨받고 현재 뷰컨트롤러에서 함수를 실행시킵니다.
    

## Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.
    
    저는 여러 뷰컨트롤러에서 사용해야할 데이터를 싱글톤으로 생성하여 앱이 실행되는 도중에 사용할 수 있도록 한 적이 있습니다.
    

## KVC
    - KVC는 `Key-Value Coding`으로 객체의 값을 직접 사용하지 않고 KeyPath를 이용해 `간접적`으로 사용하고 수정하는 방법입니다.
    - `{백슬래시(\)}.{타입}.{keypath}` 로 keypath를 만들어 사용할 수도 있습니다.

## KVO 동작 방식에 대해 설명하시오.
    - KVO는 `Key-Value Oberving`으로 어떤 Key에 등록된 변수가 변경이 되는 것을 관찰하고 변경이 발생할 때마다 특정한 작업을 수행하기 위해 사용합니다.
    - Objective-C 런타임에 의존하기 때문에 `NSObject`를 채택해야하고, 관찰할 프로퍼티에는 `@objc` 와 `dynamic` 키워드를 붙여야 합니다.

## Delegates와 Notification 방식의 차이점에 대해 설명하시오.
    
    

## 멀티 쓰레드로 동작하는 앱을 작성하고 싶을 때 고려할 수 있는 방식들을 설명하시오.

## MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.
    
    MVC는 모델 뷰 컨트롤러로 이루어져 있고 사용자의 액션을 컨트롤러가 받아 모델을 업데이트하고 보여줄 뷰를 선택하여 보여줍니다.
    
    iOS에서는 뷰와 컨트롤러가 밀접하게 붙어있는 뷰컨트롤러의 형태로 주로 사용됩니다.
    

## 프로토콜이란 무엇인지 설명하시오.
    
    프로토콜이란 구현할 속성이나 메서드에 대해 제공하는 청사진 입니다. 상속은 클래스만 할 수 있다면 프로토콜은 모든 타입이 채택하여 사용할 수 있습니다.
    
## associatedType이 무엇인지 설명해주세요
    
    프로토콜에 제네릭으로 타입을 정의할 수 있는 방법입니다.
    

## 프로토콜과 클래스의 차이
    
    클래스는 인스턴스 메서드의 실제 구현체를 가지고 있지만 프로토콜은 메서드의 인터페이스만 가지고 있습니다. 프로토콜이 구현체를 가지게 하려면 extension을 만들어 작성할 수 있습니다.
    

## Protocol Oriented Programming과 Object Oriented Programming의 차이점을 설명하시오.
    
    객체지향 프로그래밍에서 상속은 클래스만이 할 수 있지만, 프로토콜 지향프로그래밍은 클래스 뿐만 아니라 구조체, 다른 여러 타입 등 모두 채택하여 사용할 수 있습니다.
    
    또한 iOS에서의 상속은 단일상속밖에 안되지만 프로토콜은 여러개를 채택하여 사용할 수 있습니다.
    

## Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.
    
    Hashable은 값의 유일성을 보장하는 프로토콜입니다. Equatable은 값이 같은지를 비교를 제공하는 프로토콜인데 값의 유일성을 보장하려면 해시값을 비교하여 충돌이 발생했는지 알아야하기 때문에 Equatable을 채택해야 비교가 가능합니다.
    

## mutating 키워드에 대해 설명하시오.
    
    스위프트에서 값 타입 프로퍼티들은 인스턴스 메서드에 의해 수정될 수 없습니다.
    
    mutating 키워드를 메서드 앞에 붙이면 구조체나 열거형 인스턴스에서 프로퍼티를 수정할 수 있게 됩니다.
    
    mutating 키워드가 붙은 메서드를 실행하면 스위프트는 `새로운 구조체를 생성`해 변경된 프로퍼티의 값을 할당하고 반환해 현재 구조체를 대체합니다. 구조체의 불변성을 지키기 위해 이런 방법을 사용합니다.
    

## 탈출 클로저에 대하여 설명하시오.
    
    파라미터로 클로저가 사용될 때 원래는 함수 종료 시 클로저도 함께 사라지지만 이 클로저를 외부에 영역에서 사용할 수 있게 힙 영역에 저장할 수 있도록 합니다.
    

## Extension에 대해 설명하시오.
    
    클래스, 구조체, 열거형 타입에 추가적인 기능의 메서드를 사용할 수 있습니다.
    
    저장 프로퍼티는 정의할 수 고 연산 프로퍼티만 정의할 수 있습니다.
    
    소멸자는 추가할 수 없고 생성자는 편의 생성자만 정의할 수 있습니다.
    
    구조체의 경우 기존 구조체에서 생성자를 직접 구현하면 멤버와이즈 생성자가 사라지지만 구조체의 extension에 생성자를 정의하면 멤버와이즈 생성자가 사라지지 않습니다.
    
    where을 사용하면 특정한 조건을 가진 타입에 대해서만 extension을 적용할 수 있습니다.
    

## Extension 내부에서 함수를 override할 수 있는지 설명하시오.
    
    extension은 새로운 함수를 추가하기 위한 기능이지 기존 함수를 대체하기 위한 기능은 아니기 때문에 함수를 오버라이드 할 수 없습니다.
    

## 접근 제어자의 종류엔 어떤게 있는지 설명하시오.
    
    open, public, internal, fileprivate, private 이 있습니다.
    
    open과 public의 차이
    
    - `open`과 `public` 키워드 모두 `외부 모듈에서의 접근까지 허용`합니다.
    - open은 `클래스에서만 사용`할 수 있습니다.
    - open은 외부 모듈에서 클래스를 상속하는 것과 메소드 오버라이딩이 가능하지만, public은 외부 모듈에서의 클래스 상속과 메소드 오버라이딩을 `제한`합니다.
    - 동일한 모듈 내에서는 open과 public 모두 클래스 상속과 메소드 오버라이딩이 가능합니다.

## defer란 무엇인지 설명하시오.
    
    클로저에 정의된 코드가 읽어진 이후에 함수가 끝나기 전 마지막에 실행되도록 합니다.
    

## defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.
    
    defer 가 호출되지 않는 경우는 defer문을 실행하지 않고 함수가 종료되었을 때 입니다.
    

## array, set, dictionary
    
    array는 random access가 가능하여 인덱스로 요소에 접근할 수 있습니다.
    
    set은 hashable 프로토콜을 채택하는 값을 저장하여 중복되지 않은 데이터를 관리하는 컬렉션입니다. 순서를 보장하지 않으며 교집합, 차집합 등 집합 연산을 메서드로 제공합니다.
    
    dictionary는 key-value 형태로 데이터를 관리합니다. key의 타입은 Hashable 프로토콜을 채택한 타입이어야 하고 중복된 키를 허용하지 않으며 순서를 보장하지 않습니다.
    

## required
    
    required 키워드가 붙은 클래스의 생성자는 해당 클래스를 상속받는 자식 클래스가 해당 생성자를 반드시 구현하도록 강제합니다.
    
    required에는 override 키워드의 기능이 포함되어있어 override 키워드 생략이 가능합니다.
    

## @objc는 언제 사용하나요?
    
    스위프트의 api를 objective-c 런타임에 사용할 수 있도록 하기위해 사용합니다.
    

## Hashable 프로토콜
    
    스위프트의 기본 타입 중 문자열, 정수, 실수, Boolean, set 컬렉션이 Hashable 프로토콜을 채택하고 있습니다.
    
    커스텀 타입의 저장 프로퍼티가 모두 hashable 프로토콜을 채택하고 있다면 별다른 구현없이 Hashable 프로토콜을 채택하는 것 만으로 Hashable한 동작을 제공합니다.
    
    그렇지 않다면 == 메서드를 만들고 hash(into:)를 구현하여 해시값을 생성하는데 필요한 프로퍼티를 지정해주어야합니다.
    

## OperationQueue에 대해서 설명해보세요. DispatchQueue와는 어떤 것이 다른가요?
    - `OperationQueue`는 작업을 나타내는 Operation 클래스의 실행을 관리하는 큐입니다. GCD와는 다르게 OperationQueue는 객체화된 작업을 큐에서 취소할 수 있고, 큐에 등록될 최대 작업의 개수를 설정하거나, 작업 간의 `의존성`(어떤 작업이 선행되어야 하는지)에 대한 정보도 설정할 수 있습니다. 즉, DispatchQueue보다 좀 더 고수준의 API를 제공합니다.
    - OperationQueue는 `내부적으로 DispatchQueue`를 이용합니다.
    - OperationQueue는 작업을 한번 객체화 하고 고수준 API를 지원하기 때문에 DispatchQueue보다 더 `많은 리소스를 사용`합니다. 따라서 복잡하고 의존성에 대한 설정이 필요한 작업이 아니라면 DispatchQueue를 사용하는 것이 더 좋을 수도 있습니다.

## final 키워드를 클래스 앞에 붙이면 어떤 효과가 있을까요?
    
    어떤 클래스의 프로퍼티나 메서드는 다른 자식 클래스에서 오버라이드 될 수 있기 때문에 실제로 어떤 메서드를 실행할지 런타임에 실제로 실행할 메서드가 결정됩니다. (dynamic dispatch)
    
    final 키워드를 사용하면 상속되지 않다는 것을 컴파일러가 알 수 있기 때문에 컴파일 타임에 어떤 메서드를 사용할지 바로 결정할 수 있어 더 빠르게 작동한다는 효과를 기대할 수 있습니다.
    
## 가상 메서드 테이블이란? vtable
    
    컴파일 타임에 생성되어 메서드가 호출되었을때 사용할 구현체를 런타임에 특정할 수 있게 해줍니다.
    
    메서드의 주소를 배열로 가지고 있습니다.
    
    클래스마다 vtable을 가지고 있습니다.
    
## 프로퍼티 옵저버에 대해 설명해보세요
    
    저장속성의 값이 변화하는 것을 관찰하기 위해 사용합니다.
    
    willSet과 didSet을 사용해서 프로퍼티의 값이 변화할 때 실행할 작업을 정의할 수 있습니다.
    
    willSet은 newValue, didSet은 oldValue 라는 값을 제공합니다.
    
    연산 프로퍼티는 부모 클래스의 연산 프로퍼티를 오버라이딩 하는 경우에만 프로퍼티 옵저버를 추가할 수 잇습니다.??
    

## typealias 가 무엇일까요
    
    기존에 있는 타입에 새로운 별칭을 붙여서 사용하는 것입니다.
    

# **ARC**

## ARC란 무엇인지 설명하시오.
    
    Swift의 메모리 관리 기법입니다. 힙 영역에 저장되는 메모리를 관리하기 위해 사용되며 값을 참조하는 갯수를 카운트 하여 카운트가 0이 되면 메모리에서 해제됩니다.
    

## ARC와 GC의 차이점
    
    ARC는 retain과 release를 컴파일러가 컴파일 타임에 자동으로 삽입해 레퍼런스 카운트를 조절합니다.
    
    GC는 런타임에 별도로 실행하여 메모리 상탤를 감시합니다.
    
    ARC는 카운팅으로 인스턴스를 관리하여 순환참조의 위험이 있습니다.
    
    GC는 모든 인스턴스를 체크하기 때문에 순환참조가 발생해도 해제할 수 있습니다. 하지만 느리다.
    

## property wrapper에 대해서 설명하시오.

## Generic에 대해 설명하시오.
    
    프로토콜, 클래스, 구조체 등에서 구현은 같지만 타입만 다를때 여러번 반복 구현을 하지 않기 위해 제네릭 타입을 사용해서 구현하면 어떤 타입이 들어와도 같은 구현을 제공할 수 있습니다.
    

## some 키워드에 대해 설명하시오.
    - some은 `opqaue result type`입니다.
    - 함수 내부에서 반환되는 타입을 외부에서 명확하게 알 수 없도록합니다.

## Result타입에 대해 설명하시오.
    
    enum 형태로 되어있고 success 와 failure 케이스가 있습니다. failure의 연관값은 Error 프로토콜을 채택해야합니다.
    
    URLSession 사용 시 escaping 클로저에 Result 타입을 사용해서 작업의 성공여부와 결과를 쉽게 표현할 수 있습니다.
    
## @escaping
    
    함수의 인자로 전달된 클로저를 함수가 종료된 후에도 실행될 수 있도록 하는 어노테이션입니다.
    

## Codable에 대하여 설명하시오.
    
    decodable, encodable를 모두 채택하는 typealias 입니다.
    
    encodable은 객체를 JSON 같은 외부 데이터 형태로 변환하는 기능을 제공하고, decodable은 Json 같은 외부데이터를 스위프트 내부 타입으로 변환할 수 있는 기능을 제공하는 프로토콜입니다.
    

## Retain Count 방식에 대해 설명하시오.
    
    참조할 때 + 1, 해제될 때 -1
    

## Strong 과 Weak 참조 방식에 대해 설명하시오.
    
    Strong 은 레퍼런트 카운트를 올리지만, weak은 레퍼런스 카운트를 올리지 않습니다.
    

## 순환 참조에 대하여 설명하시오.
    
    서로 메모리를 참조하고 있어 메모리에서 해제되지 않는 상태
    

## 강한 순환 참조 (Strong Reference Cycle) 는 어떤 경우에 발생하는지 설명하시오.
    
    어떤 두 클래스 인스턴스가 프로퍼티에 서로를 강한 참조로 저장하고 있을 때 강한 순환 참조가 발생할 수 있습니다.
    
## strong, weak, unowned 레퍼런스는 각각 언제 사용할까요?
    
    메모리에서 인스턴스가 해제되는 것을 막기 위해 strong reference를 사용할 수 있습니다.
    
    weak는 참조 카운트를 증가시키지 않습니다. weak는 항상 var로 선언되는 옵셔널 타입이 되어야합니다. weak으로 참조하고 있던 인스턴스가 해제되어 nil이 될 수 있기 때문입니다. 순환 참조의 가능성이 있는 상황에서 weak을 통해 방지할 수 있습니다.
    
    unowned는 weak과 동일하게 참조 카운트를 증가시키지 않습니다. 그리고 동시에 nil을 가질 수 없다는 특징이 있습니다. unowned로 참조하고 있던 인스턴스가 해제되고 이때 변수를 참조하려고 하면 런타임 에러가 발생합니다. 따라서 unowned는 해당 변수가 참조하는 인스턴스보다 먼저 해제되는 것이 확실할 때만 사용해야합니다. 옵셔널 타입이 아니기 때문에 옵셔널 바인딩을 사용하지 않아도 된다는 장점이 있습니다.
    
## unowned도 사용하는 이유는?
    
    옵셔널을 신경쓰지 않아도 된다는 장점이 있고, 명시적으로 참조하고 있는 인스턴스가 unowned 프로퍼티가 해제되기 전에 메모리에서 해제된다는 것을 표현할 수 있습니다.
    

## DispatchSemahore 를 사용하는 상황을 설명해주세요
    
    락으로 사용할 수 있습니다. 어떤 공유자원에 한번에 정해진 스레드들만 접근할 수 있도록 허용할 때 DispatchSemaphore를 사용할 수 있습니다. wait은 세마포어의 값을 줄이고, signal을 증가시킵니다.
    

# **Functional Programming**

## 순수함수란 무엇인지 설명하시오.
    
    어떤 입력에 대해 항상 같은 출력을 만드는 함수를 의미합니다.
    
    따라서 외부에 영향을 주거나 받는 side effect가 없습니다.
    

## 순수함수가 필요한 이유?
    
    같은 입력에 대해 항상 같은 출력을 하는 순수함수는 테스트가 용이합니다. 외부 상태에 영향을 받지 않아 해당 함수만을 테스트할 수 있기 때문입니다.
    
    사이드 이펙트가 없다는 것은 순수 함수를 가지는 객체의 유지보수성이 좋다는 것을 의미합니다. 프로퍼티나 다른 함수들에 의존적이지 않기 때문에 확장과 변경이 쉽게 가능합니다.
    

## 1급 객체에 대해 설명해보세요. Swift에는 어떤 1급 객체들이 있나요?
    
    1급 객체는 변수나 상수에 값을 할당할 수 있고, 함수의 파라미터로 사용하거나 반환값으로 사용할 수 있는 객체를 의미합니다. 
    
    스위프트는 기본 타입들과 함수, 클로저 모두 1급 객체에 해당합니다.
    

## side effect란 무엇인가요?
    
    함수를 통해 함수 외부 값의 상태가 변하는 것을 의미합니다.
    

## 함수형 프로그래밍이 무엇인지 설명하시오.
    
    이미 존재하는 함수들을 조합하여 결과물을 만들어내는 프로그래밍
    

## 고차 함수가 무엇인지 설명하시오.
    
    함수를 인자로 받거나 함수를 결과로 반환할 수 있는 함수입니다.
    

## Swift Standard Library의 map, filter, reduce, compactMap, flatMap에 대하여 설명하시오.

# **Architecture**

## MVVM, MVI, Ribs, VIP 등 자신이 알고있는 아키텍쳐를 설명하시오.

## 의존성 주입에 대하여 설명하시오.

# **SwiftUI**

## @State에 대해서 설명하시오.

# **Combine**

## PassthroughSubject에 대해서 설명하시오
## @Published에 대해서 설명하시오
## AnyCancellable에 대해서 설명하시오
## sink에 대해서 설명하시오
## throttle과 debounce의 차이점을 설명하시오.
