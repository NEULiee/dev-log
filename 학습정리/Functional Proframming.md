[다시 쓰는 함수형 프로그래밍](https://velog.io/@teo/functional-programming)

[](https://simsimjae.tistory.com/396)

[부수 효과 (Side Effect), 참조 투명성 (Referential Transparency)](https://jinwooe.wordpress.com/2017/12/21/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC-side-effect-%EC%B0%B8%EC%A1%B0-%ED%88%AC%EB%AA%85%EC%84%B1-referential-transparency/)

# 패러다임이란?

코드를 작성할 때 좋은 설계를 유지하기 위해 사용하는 **일관적인 원칙과 규칙**

좋은 설계란 코드의 생산성이 높앚

# 스위프트의 프로그래밍 패러다임

1. ****객체지향 프로그래밍(Object-Oriented Programming)****
    
    객체를 중심으로 사고하여 프로그래밍하는 것
    
2. ****프로토콜 지향 프로그래밍(Protocol-Oriented Programming)****
    
    데이터를 함수로 연결하는 것을 중심으로 사고하고 프로그래밍하는 것
    
3. ****함수형 프로그래밍(Functional Programming)****

💡 **멀티 패러다임** : 객체지향 프로그래밍 + 함수형 프로그래밍

# 함수형 프로그래밍 (Functional Programming)

> 함수를 사용해서 사이드 이펙트가 없도록 선언형으로 프로그래밍하는 것
> 
- 함수가 1급 객체로 변수, 매개변수, 리턴값에 할당될 수 있습니다.
- 함수형 프로그래밍의 장점
    - 함수형 프로그램은 결정론적이기 때문에 원인을 찾기 쉽다.
    - 함수형 프로그램은 테스트하기 쉽다. 
    사이드 이펙트가 없기 때문에 mock을 만들지 않아도 된다.
    - 함수형 프로그램은 조립하기가 쉽다. 함수들의 조합으로 구성할 수 있다.
    사이드 이펙트가 없고, 예외가 없으며, 값의 변경이 일어나지 않는다. 동시성도 문제 x
    - 함수형 프로그램은 구성, 재구성이 쉽다. 함수형 프로그램을 작성할 때, 기반이 되는 함수들을 먼저 작성한 후에 상위 레벨에서 함수들을 조합한다.
    - 모든 함수는 참조 투명하기 때문에 다른 프로그램을 작성할 때도 코드의 변경없이 재사용 할 수 있다.

## 순수함수

> 사이드 이펙트가 없으며 같은 인풋에 같은 아웃풋을 내는 함수
> 

## Side Effect: 함수형 프로그래밍에서 사이드이펙트

> 함수에서 함수 외부의 어떤 것을 변경하게 되는 것
> 
- 프로젝트에 사이드 이펙트를 가진  함수가 많아지면 디버깅하기 굉장히 어려워진다.

## 참조투명성

> 함수가 함수 외부의 영향을 받지 않는것
> 
- 함수의 결과는 입력 파라미터에만 의존하고, 함수의 외부인 콘솔, 파일, 원격, URL, 데이터베이스, 파일 시스템 등에서 데이터를 읽지 않는다.
- 참조 투명성을 가진 코드는 아래와 같은 특징들을 지닌다.
    - 자기 충족적이다 (self-contained). 함수 외부에 의존하는 코드가 없고, 함수 사용자 입장에서는 유효한 매개변수만 전달하면 된다.
    - 결정론적이다 (deterministic). 동일한 매개변수에 대해서는 항상 동일한 결과가 나온다.
    - 예외 (Exception) 를 던지지 않는다. out of memory error 혹은 stack overflow error 는 발생할 수 있지만, 이러한 에러들은 버그로 취급되며, 함수의 사용자가 다룰 수 있는 것은 아니다.
    - 다른 코드가 예기치 않게 실패하는 조건을 만들지 않는다. 예를 들어, 참조 투명성을 가진 함수는 매개 변수의 값을 변경하거나 함수 외부의 데이터를 변경하지 않는다.
    - 데이터베이스, 파일 시스템, 네트워크 등의 외부 기기로 인해 동작이 멈추지 (hang) 않는다.

# 명령형 프로그래밍과 함수형 프로그래밍

|  | 명령형 프로그래밍 | 함수형 프로그래밍 |
| --- | --- | --- |
| 프로그램이란? | 명령의 수행 | 함수의 계산 |
| 중점적 시각 | How 어떻게 구현할까 - 설계 | What 무엇을 구현할까 - 선언적 |
| 프로그래밍 언어 | C, 자바 등 대부분의 언어… | Scheme, ML, Erlang… |

# 클로저

> 이름이 없는 (익명) 함수
> 
- 함수를 실행할 때 전달하는 형태로 사용하기 때문에 이름이 필요없다.
- 함수와 기능은 동일하지만 형태가 다르다.

```swift
함수
func function() -> Int {
    return ...
}

클로저
{ () -> Int in
	return ...
}
```

## 스위프트는 함수를 “일급객체"로 취급한다.

**함수는 타입이다.**

1. `함수`를 변수에 할당할 수 있다.
2. 함수를 호출할 때, `함수`를 파라미터로 전달할 수 있다.
3. 함수에서 `함수`를 반환할 수 있다.


## 콜백함수

> 함수를 실행하면서 **파라미터로 전달하는 함수**
> 
1. 클로저를 파라미터로 받는 함수를 정의
2. 함수를 실행할 때 파라미터를 클로저 형태로 전달한다.


💡 하고 싶은 일을 함수 실행 시 개발자가 원하는대로 정의할 수 있기 때문에 **활용도**가 늘어난다.


함수의 실행이 종료되면 파라미터로 쓰이는 클로저도 제거된다.
